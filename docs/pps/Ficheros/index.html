<!doctype html><html lang=en dir=ltr><head><script src="/livereload.js?mindelay=10&v=2&port=1313&path=livereload" data-no-instant defer></script><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="<h2>El puntero a un archivo:&amp;nbsp;FILE *fptr;</h2><ul><li><span style=&#34;font-size: 12pt;&#34;><em><strong>fptr</strong></em> es un puntero a una estructura que define información sobre un archivo, incluyendo el nombre, el estado y la posición actual en el archivo. Es mantenido por el sistema y resulta clave para el funcionamiento de las funciones de E/S con buffer</span></li><li><span style=&#34;font-size: 12pt;&#34;>El tipo <em><strong>FILE</strong></em>&amp;nbsp;(descriptor de fichero) se define en <em><strong>stdio.h</strong></em></span></li><li><span style=&#34;font-size: 12pt;&#34;>Los archivos se dicen de texto o binarios según la naturaleza de su contenido</span></li></ul><h5>Declaración 1:</h5><pre>struct file {  mode_t f_mode;  loff_t f_pos;  unsigned short f_flags;  unsigned short f_count;  unsigned long f_reada, f_ramax, f_raend, f_ralen, f_rawin;  struct file *f_next, *f_prev;  int f_owner;         /* pid or -pgrp where SIGIO should be sent */  struct inode * f_inode;  struct file_operations * f_op;  unsigned long f_version;  void *private_data;  /* needed for tty driver, and maybe others */};</pre><h2>Resumen de funciones</h2><ul><li><span style=&#34;font-size: 12pt;&#34;>fopen(): Abre un archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fclose(): Cierra un archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fgets(): Lee un string</span></li><li><span style=&#34;font-size: 12pt;&#34;>fputs(): Escribe string</span></li><li><span style=&#34;font-size: 12pt;&#34;>ftell(), fseek(): Recorrer archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fprintf(): Escribe una salida con formato en el archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fscanf(): Lee una entrada con formato desde el archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>feof(): Cierto si fin del archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>ferror(): Cierto si se produce un error</span></li><li><span style=&#34;font-size: 12pt;&#34;>rewind(): Se posiciona al principio del mismo</span></li><li><span style=&#34;font-size: 12pt;&#34;>remove(): Borra archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fflush(): Vacia archivo</span></li></ul><p>&amp;nbsp;</p><h2>Operaciones básicas</h2><h3>Apertura de un archivo</h3><p><span style=&#34;font-size: 12pt;&#34;>1 abre un bu<span style=&#34;font-size: 12pt;&#34;>ffer y lo asocia a un archivo</span></span></p><p><em><span style=&#34;font-size: 12pt;&#34;>FILE * fopen(const char * nombre_archivo, const char * modo);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>nombre_archivo es un puntero a una cadena de caracteres que representan un nombre valido del&amp;nbsp;</span><span style=&#34;font-size: 12pt;&#34;>archivo y puede incluir una especificación del directorio (path)&amp;nbsp;</span><span style=&#34;font-size: 12pt;&#34;>la cadena a la que apunta modo determina como se abre el archivo. Los valores permitidos para modo son:</span></p><ul><li><span style=&#34;font-size: 12pt;&#34;>&amp;nbsp;r: Abre un archivo de texto para lectura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>w: Crea un archivo de texto para escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>a: Abre un archivo de texto para añadir</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>rb: Abre un archivo en modo lectura binaria</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>wb: Crea un archivo en modo escritura binaria</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>ab: Abre un archivo binario para añadir</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>r+: Abre un archivo de texto para lectura&amp;nbsp;/ escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>w+: Crea un archivo de texto para escritura&amp;nbsp;/ escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>a+: Añade o crea un archivo de texto para lectura / escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>r+b: Abre un archivo binario para lectura / escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>w+b: Crea un archivo binario para lectura / escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>a+b: Añade o crea un archivo binario para lectura / escritura</span></li></ul><p><span style=&#34;font-size: 12pt;&#34;>Siempre conviene tener presente lo siguiente:</span></p><ul><li><span style=&#34;font-size: 12pt;&#34;>fopen() devuelve un puntero a archivo. Un programa nunca debe alterar el valor de ese puntero. Si se produce un error cuando se esta intentando abrir un archivo, fopen() devuelve un puntero nulo</span></li><li><span style=&#34;font-size: 12pt;&#34;>El modo texto o binario tiene múltiples implicaciones. Por ejemplo, la relativa a la interpretación de los caracteres especiales como son el salto de línea (retorno de carro) o el fin de línea</span></li></ul><h3>Cierre de un archivo</h3><p><span style=&#34;font-size: 12pt;&#34;>fclose() cierra una secuencia o buffer previamente abierta mediante una llamada a fopen(). Escribe toda la </span><span style=&#34;font-size: 12pt;&#34;>información aún en el buffer al disco y realiza un cierre formal del archivo a nivel del sistema </span><span style=&#34;font-size: 12pt;&#34;>operativo. Un error en el cierre (el no cierre, por ejemplo) de una secuencia puede generar todo tipo de problemas, incluyendo la pérdida de los datos, la destrucción de archivos y probables errores esotéricos en el programa. El prototipo de esta función es:</span></p><p><em><span style=&#34;font-size: 12pt;&#34;>int fclose(FILE *F);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Si devuelve un valor cero significa éxito (curioso, pero cierto ?)</span></p><h3>Leer y/o escribir en un archivo con fprintf() y fscanf()</h3><p><em><span style=&#34;font-size: 12pt;&#34;>int fprintf(FILE *F, const char *cadena_de_control, .....); </span></em><br /><em><span style=&#34;font-size: 12pt;&#34;>int fscanf(FILE *F, const char *cadena_de_control, .....);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Como <a href=&#34;https://www.tutorialspoint.com/c_standard_library/c_function_printf.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;><em><strong>prinft()</strong></em></a> y <a href=&#34;https://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;><em><strong>scanf()</strong></em></a> excepto que operan sobre archivo</span></p><h3>Leer y/o escribir en un archivo con 1 y 1</h3><p><span style=&#34;font-size: 12pt;&#34;>Funciones especialmente adecuadas para leer y escribir archivos de texto</span></p><h4><em><span style=&#34;font-size: 12pt;&#34;>char *fgets(char *str, int long, FILE *F);</span></em>&amp;nbsp;</h4><p><span style=&#34;font-size: 12pt;&#34;>Si se alcanza el EOF (End of File) la llamada fgets() retorna NULL</span></p><h4><em><span style=&#34;font-size: 12pt;&#34;>char *fputs(char *str, FILE *F);</span></em></h4><pre class=&#34;prettyprint notranslate prettyprinted&#34;><span class=&#34;pln&#34;>   char buff[1024]; // Buffer en memoria de 1024 caracteres<br />   FILE </span><span class=&#34;pun&#34;>*</span><span class=&#34;pln&#34;>fd</span><span class=&#34;pun&#34;>;        // Descriptor de fichero</span><span class=&#34;pln&#34;>   </span><span class=&#34;pln&#34;></span><span class=&#34;pln&#34;>   fd </span><span class=&#34;pun&#34;>=</span><span class=&#34;pln&#34;> fopen</span><span class=&#34;pun&#34;>(</span><span class=&#34;str&#34;>&#34;/tmp/ejemplo.txt&#34;</span><span class=&#34;pln&#34;> </span><span class=&#34;pun&#34;>,</span><span class=&#34;pln&#34;> </span><span class=&#34;str&#34;>&#34;r&#34;</span><span class=&#34;pun&#34;>); // Abrir en modo solo lectura</span><span class=&#34;pln&#34;>   </span><span class=&#34;kwd&#34;>if</span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;>fd </span><span class=&#34;pun&#34;>==</span><span class=&#34;pln&#34;> NULL</span><span class=&#34;pun&#34;>)</span><span class=&#34;pln&#34;> </span><span class=&#34;pun&#34;>{</span><span class=&#34;pln&#34;>      perror</span><span class=&#34;pun&#34;>(</span><span class=&#34;str&#34;>&#34;Error al abrir /tmp/ejemplo.txt&#34;</span><span class=&#34;pun&#34;>); // Mostrar error en stderr</span><span class=&#34;pln&#34;>      </span><span class=&#34;kwd&#34;>return</span><span class=&#34;pun&#34;>(-</span><span class=&#34;lit&#34;>1</span><span class=&#34;pun&#34;>);   // Devolver error genérico</span><span class=&#34;pln&#34;>   </span><span class=&#34;pun&#34;>}<br /></span><span class=&#34;pln&#34;>   // Leer máximo 1024 caracteres; podrían ser menos<br />   // buff funciona indistintamente como char[] y char *   </span><span class=&#34;kwd&#34;>if</span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;> fgets </span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;>buff</span><span class=&#34;pun&#34;>,</span><span class=&#34;pln&#34;> </span><span class=&#34;lit&#34;>1024</span><span class=&#34;pun&#34;>,</span><span class=&#34;pln&#34;> fd</span><span class=&#34;pun&#34;>) != </span><span class=&#34;pln&#34;>NULL </span><span class=&#34;pun&#34;>)</span><span class=&#34;pln&#34;></span><span class=&#34;pln&#34;></span><span class=&#34;pln&#34;>      fputs</span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;>buff, stdout</span><span class=&#34;pun&#34;>);  // imprime buffer en stdout</span><span class=&#34;pln&#34;></span><span class=&#34;pln&#34;>   fclose</span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;>fp</span><span class=&#34;pun&#34;>);      // OJO: cerrar siempre el descriptor para evitar efectos paranormales</span><span class=&#34;pln&#34;></span></pre><p><span style=&#34;color: inherit; font-family: inherit; font-size: 18px; font-weight: bold;&#34;>Fin de archivo feof()</span></p><p><em><span style=&#34;font-size: 12pt;&#34;>int feof(FILE *F);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Cuando se abre un archivo para entrada binaria, la propia marca EOF se puede leer como un dato cualquiera. Esto podría hacer que la rutina de lectura indicase fin de archivo aún cuando el final físico no se </span><span style=&#34;font-size: 12pt;&#34;>haya alcanzado. Para resolver este problema, C incluye la función feof(), que determina cuando se ha alcanzado el real del archivo leyendo datos binarios</span></p><p><span style=&#34;font-size: 12pt;&#34;>Su prototipo se encuentra en <em><strong>stdio.h</strong></em>. Devuelve cierto si se ha alcanzado el final del archivo, en cualquier </span><span style=&#34;font-size: 12pt;&#34;>otro caso, 0. Por supuesto (moraleja), se puede aplicar también a archivos de texto</span></p><h3>Recorrer archivo con&amp;nbsp;1&amp;nbsp;y&amp;nbsp;1</h3><p><span style=&#34;font-size: 12pt;&#34;>Estas dos funciones son interesantes para cosas como, por ejemplo, leer un fichero al revés (hay, sin embargo, formas mejores de hacer lo mismo)</span></p><h4><em><span style=&#34;font-size: 12pt;&#34;>int fseek(</span></em><em><span style=&#34;font-size: 12pt;&#34;>FILE *F, long int desplz</span></em><em><span style=&#34;font-size: 12pt;&#34;>, int posact);</span></em>&amp;nbsp;</h4><p><span style=&#34;font-size: 12pt;&#34;>Se desplaza el nº de bytes que indica desplaz desde la posición que indica posact. Esta puede vales <em><strong>SEEK_SET</strong></em> (inicio absoluto del fichero), <strong><em>SEEK_CUR</em></strong> (posición actual) o <strong><em>SEEK_END</em></strong></span></p><p><span style=&#34;font-size: 12pt;&#34;>Si no hubo error devuelve 0</span></p><h4><em style=&#34;color: inherit; font-family: inherit;&#34;><span style=&#34;font-size: 12pt;&#34;>long int ftell(</span></em><em style=&#34;color: inherit; font-family: inherit;&#34;><span style=&#34;font-size: 12pt;&#34;>FILE *F</span></em><em style=&#34;color: inherit; font-family: inherit;&#34;><span style=&#34;font-size: 12pt;&#34;>);</span></em></h4><p><span style=&#34;font-size: 12pt;&#34;>No tiene misterio alguno. Devuelve el valor actual&amp;nbsp;del indicador de posición o -1 si error</span></p><h3>Función ferror()</h3><p><em><span style=&#34;font-size: 12pt;&#34;>int ferror(FILE *F);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Su prototipo se encuentra en <em><strong>stdio.h</strong></em>. Determina si se ha producido error en una operación sobre un archivo.&amp;nbsp;</span><span style=&#34;font-size: 12pt;&#34;>F es un puntero a un archivo válido. Devuelve cierto (1) si se ha producido un error en la última&amp;nbsp;</span><span style=&#34;font-size: 12pt;&#34;>operación sobre el archivo. En caso contrario, devuelve falso (0). Debido a que cada operación sobre el archivo actualiza la condicioón de error, se debe llamar a ferror() inmediatamente después de la operación</span></p><h3>Función remove()</h3><p><em><span style=&#34;font-size: 12pt;&#34;>int remove(char *nombre_archivo);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Borra el archivo especificado. Devuelve cero si tiene éxito</span></p><h3>Función fflush()</h3><p><em><span style=&#34;font-size: 12pt;&#34;>int fflush(FILE *F);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Escribe todos los datos en el buffer sobre el archivo en el disco</span></p><p><span style=&#34;font-size: 12pt;&#34;>Si se llama esta función con un puntero nulo se vacían todos los buffers de todos los archivos abiertos. Devuelve cero si tiene éxito, en otro caso, devuelve EOF</span>&amp;nbsp;</p><h2>Ejemplo</h2><pre><span class=&#34;cp&#34;>#include</span> <span class=&#34;cpf&#34;>&amp;lt;stdio.h&amp;gt;</span><span class=&#34;cp&#34;>#include</span> <span class=&#34;cpf&#34;>&amp;lt;stdlib.h&amp;gt;</span> <span class=&#34;kt&#34;>int</span> <span class=&#34;nf&#34;>main</span><span class=&#34;p&#34;>()</span><span class=&#34;p&#34;>{</span> 	<span class=&#34;kt&#34;>FILE</span> <span class=&#34;o&#34;>*</span><span class=&#34;n&#34;>archivo</span><span class=&#34;p&#34;>;</span> 	 	<span class=&#34;kt&#34;>char</span> <span class=&#34;n&#34;>caracteres</span><span class=&#34;p&#34;>[</span><span class=&#34;mi&#34;>100</span><span class=&#34;p&#34;>];               /* un buffer de tamaño 100 */</span> 	 	<span class=&#34;n&#34;>archivo</span> <span class=&#34;o&#34;>=</span> <span class=&#34;n&#34;>fopen</span><span class=&#34;p&#34;>(</span><span class=&#34;s&#34;>&#34;pepito.txt&#34;</span><span class=&#34;p&#34;>, </span><span class=&#34;s&#34;>&#34;r&#34;</span><span class=&#34;p&#34;>); /* abrir el archivo */</span> 	 	<span class=&#34;k&#34;>if</span> <span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>archivo</span> <span class=&#34;o&#34;>==</span> <span class=&#34;nb&#34;>NULL</span><span class=&#34;p&#34;>)</span> 		<span class=&#34;n&#34;>exit</span><span class=&#34;p&#34;>(</span><span class=&#34;mi&#34;>1</span><span class=&#34;p&#34;>);                    /* no fue abierto, salir corriendo */</span> 	<span class=&#34;k&#34;>else</span>        <span class=&#34;p&#34;>{</span> 	    <span class=&#34;n&#34;>printf</span><span class=&#34;p&#34;>(</span><span class=&#34;s&#34;>&#34;</span><span class=&#34;se&#34;>
</span><span class=&#34;s&#34;>El contenido del archivo es </span><span class=&#34;se&#34;>

</span><span class=&#34;s&#34;>&#34;</span><span class=&#34;p&#34;>);</span> 	    <span class=&#34;k&#34;>while</span> <span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>feof</span><span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>archivo</span><span class=&#34;p&#34;>)</span> <span class=&#34;o&#34;>==</span> <span class=&#34;mi&#34;>0</span><span class=&#34;p&#34;>)      /* mientras no alcance el final <strong>real</strong> */</span> 	    <span class=&#34;p&#34;>{</span> 		printf(&#34;Ahora LEE
&#34;);<br /><span class=&#34;n&#34;>                fgets</span><span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>caracteres</span><span class=&#34;p&#34;>, </span><span class=&#34;mi&#34;>100</span><span class=&#34;p&#34;>, </span><span class=&#34;n&#34;>archivo</span><span class=&#34;p&#34;>); /* ojo, lee de 100 en 100 */<br /></span>                printf(&#34;Ahora ESCRIBE
&#34;);  		<span class=&#34;n&#34;>printf</span><span class=&#34;p&#34;>(</span><span class=&#34;s&#34;>&#34;%s&#34;</span><span class=&#34;p&#34;>,</span><span class=&#34;n&#34;>caracteres</span><span class=&#34;p&#34;>);</span> 	    <span class=&#34;p&#34;>}</span>        <span class=&#34;p&#34;>}</span>        <span class=&#34;n&#34;>fclose</span><span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>archivo</span><span class=&#34;p&#34;>);                    /* salir cerrando el archivo */</span>	<span class=&#34;k&#34;>return</span> <span class=&#34;mi&#34;>0</span><span class=&#34;p&#34;>;</span><span class=&#34;p&#34;>}</span></pre><h1>Ejercicio</h1><p><span style=&#34;font-size: 12pt;&#34;>El ejercicio Struct Libro del tema 1 incluye manejo de ficheros. Descargar 1</span></p><h2>Información adicional</h2><ol><li><a href=&#34;https://www.tutorialspoint.com/cprogramming/c_file_io.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;><span style=&#34;font-size: 12pt;&#34;>C File I/O</span></a></li><li><a href=&#34;https://www.tutorialspoint.com/c_standard_library/stdio_h.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;><span style=&#34;font-size: 12pt;&#34;>C Library &amp;lt;stdio.h&amp;gt;</span></a></li></ol>"><meta name=theme-color content="#FFFFFF"><meta property="og:title" content="Manejo de Ficheros en C"><meta property="og:description" content="<h2>El puntero a un archivo:&amp;nbsp;FILE *fptr;</h2><ul><li><span style=&#34;font-size: 12pt;&#34;><em><strong>fptr</strong></em> es un puntero a una estructura que define información sobre un archivo, incluyendo el nombre, el estado y la posición actual en el archivo. Es mantenido por el sistema y resulta clave para el funcionamiento de las funciones de E/S con buffer</span></li><li><span style=&#34;font-size: 12pt;&#34;>El tipo <em><strong>FILE</strong></em>&amp;nbsp;(descriptor de fichero) se define en <em><strong>stdio.h</strong></em></span></li><li><span style=&#34;font-size: 12pt;&#34;>Los archivos se dicen de texto o binarios según la naturaleza de su contenido</span></li></ul><h5>Declaración 1:</h5><pre>struct file {  mode_t f_mode;  loff_t f_pos;  unsigned short f_flags;  unsigned short f_count;  unsigned long f_reada, f_ramax, f_raend, f_ralen, f_rawin;  struct file *f_next, *f_prev;  int f_owner;         /* pid or -pgrp where SIGIO should be sent */  struct inode * f_inode;  struct file_operations * f_op;  unsigned long f_version;  void *private_data;  /* needed for tty driver, and maybe others */};</pre><h2>Resumen de funciones</h2><ul><li><span style=&#34;font-size: 12pt;&#34;>fopen(): Abre un archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fclose(): Cierra un archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fgets(): Lee un string</span></li><li><span style=&#34;font-size: 12pt;&#34;>fputs(): Escribe string</span></li><li><span style=&#34;font-size: 12pt;&#34;>ftell(), fseek(): Recorrer archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fprintf(): Escribe una salida con formato en el archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fscanf(): Lee una entrada con formato desde el archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>feof(): Cierto si fin del archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>ferror(): Cierto si se produce un error</span></li><li><span style=&#34;font-size: 12pt;&#34;>rewind(): Se posiciona al principio del mismo</span></li><li><span style=&#34;font-size: 12pt;&#34;>remove(): Borra archivo</span></li><li><span style=&#34;font-size: 12pt;&#34;>fflush(): Vacia archivo</span></li></ul><p>&amp;nbsp;</p><h2>Operaciones básicas</h2><h3>Apertura de un archivo</h3><p><span style=&#34;font-size: 12pt;&#34;>1 abre un bu<span style=&#34;font-size: 12pt;&#34;>ffer y lo asocia a un archivo</span></span></p><p><em><span style=&#34;font-size: 12pt;&#34;>FILE * fopen(const char * nombre_archivo, const char * modo);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>nombre_archivo es un puntero a una cadena de caracteres que representan un nombre valido del&amp;nbsp;</span><span style=&#34;font-size: 12pt;&#34;>archivo y puede incluir una especificación del directorio (path)&amp;nbsp;</span><span style=&#34;font-size: 12pt;&#34;>la cadena a la que apunta modo determina como se abre el archivo. Los valores permitidos para modo son:</span></p><ul><li><span style=&#34;font-size: 12pt;&#34;>&amp;nbsp;r: Abre un archivo de texto para lectura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>w: Crea un archivo de texto para escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>a: Abre un archivo de texto para añadir</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>rb: Abre un archivo en modo lectura binaria</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>wb: Crea un archivo en modo escritura binaria</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>ab: Abre un archivo binario para añadir</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>r+: Abre un archivo de texto para lectura&amp;nbsp;/ escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>w+: Crea un archivo de texto para escritura&amp;nbsp;/ escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>a+: Añade o crea un archivo de texto para lectura / escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>r+b: Abre un archivo binario para lectura / escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>w+b: Crea un archivo binario para lectura / escritura</span></li><li><span style=&#34;font-size: 12pt;&#34;></span><span style=&#34;font-size: 12pt;&#34;>a+b: Añade o crea un archivo binario para lectura / escritura</span></li></ul><p><span style=&#34;font-size: 12pt;&#34;>Siempre conviene tener presente lo siguiente:</span></p><ul><li><span style=&#34;font-size: 12pt;&#34;>fopen() devuelve un puntero a archivo. Un programa nunca debe alterar el valor de ese puntero. Si se produce un error cuando se esta intentando abrir un archivo, fopen() devuelve un puntero nulo</span></li><li><span style=&#34;font-size: 12pt;&#34;>El modo texto o binario tiene múltiples implicaciones. Por ejemplo, la relativa a la interpretación de los caracteres especiales como son el salto de línea (retorno de carro) o el fin de línea</span></li></ul><h3>Cierre de un archivo</h3><p><span style=&#34;font-size: 12pt;&#34;>fclose() cierra una secuencia o buffer previamente abierta mediante una llamada a fopen(). Escribe toda la </span><span style=&#34;font-size: 12pt;&#34;>información aún en el buffer al disco y realiza un cierre formal del archivo a nivel del sistema </span><span style=&#34;font-size: 12pt;&#34;>operativo. Un error en el cierre (el no cierre, por ejemplo) de una secuencia puede generar todo tipo de problemas, incluyendo la pérdida de los datos, la destrucción de archivos y probables errores esotéricos en el programa. El prototipo de esta función es:</span></p><p><em><span style=&#34;font-size: 12pt;&#34;>int fclose(FILE *F);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Si devuelve un valor cero significa éxito (curioso, pero cierto ?)</span></p><h3>Leer y/o escribir en un archivo con fprintf() y fscanf()</h3><p><em><span style=&#34;font-size: 12pt;&#34;>int fprintf(FILE *F, const char *cadena_de_control, .....); </span></em><br /><em><span style=&#34;font-size: 12pt;&#34;>int fscanf(FILE *F, const char *cadena_de_control, .....);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Como <a href=&#34;https://www.tutorialspoint.com/c_standard_library/c_function_printf.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;><em><strong>prinft()</strong></em></a> y <a href=&#34;https://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;><em><strong>scanf()</strong></em></a> excepto que operan sobre archivo</span></p><h3>Leer y/o escribir en un archivo con 1 y 1</h3><p><span style=&#34;font-size: 12pt;&#34;>Funciones especialmente adecuadas para leer y escribir archivos de texto</span></p><h4><em><span style=&#34;font-size: 12pt;&#34;>char *fgets(char *str, int long, FILE *F);</span></em>&amp;nbsp;</h4><p><span style=&#34;font-size: 12pt;&#34;>Si se alcanza el EOF (End of File) la llamada fgets() retorna NULL</span></p><h4><em><span style=&#34;font-size: 12pt;&#34;>char *fputs(char *str, FILE *F);</span></em></h4><pre class=&#34;prettyprint notranslate prettyprinted&#34;><span class=&#34;pln&#34;>   char buff[1024]; // Buffer en memoria de 1024 caracteres<br />   FILE </span><span class=&#34;pun&#34;>*</span><span class=&#34;pln&#34;>fd</span><span class=&#34;pun&#34;>;        // Descriptor de fichero</span><span class=&#34;pln&#34;>   </span><span class=&#34;pln&#34;></span><span class=&#34;pln&#34;>   fd </span><span class=&#34;pun&#34;>=</span><span class=&#34;pln&#34;> fopen</span><span class=&#34;pun&#34;>(</span><span class=&#34;str&#34;>&#34;/tmp/ejemplo.txt&#34;</span><span class=&#34;pln&#34;> </span><span class=&#34;pun&#34;>,</span><span class=&#34;pln&#34;> </span><span class=&#34;str&#34;>&#34;r&#34;</span><span class=&#34;pun&#34;>); // Abrir en modo solo lectura</span><span class=&#34;pln&#34;>   </span><span class=&#34;kwd&#34;>if</span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;>fd </span><span class=&#34;pun&#34;>==</span><span class=&#34;pln&#34;> NULL</span><span class=&#34;pun&#34;>)</span><span class=&#34;pln&#34;> </span><span class=&#34;pun&#34;>{</span><span class=&#34;pln&#34;>      perror</span><span class=&#34;pun&#34;>(</span><span class=&#34;str&#34;>&#34;Error al abrir /tmp/ejemplo.txt&#34;</span><span class=&#34;pun&#34;>); // Mostrar error en stderr</span><span class=&#34;pln&#34;>      </span><span class=&#34;kwd&#34;>return</span><span class=&#34;pun&#34;>(-</span><span class=&#34;lit&#34;>1</span><span class=&#34;pun&#34;>);   // Devolver error genérico</span><span class=&#34;pln&#34;>   </span><span class=&#34;pun&#34;>}<br /></span><span class=&#34;pln&#34;>   // Leer máximo 1024 caracteres; podrían ser menos<br />   // buff funciona indistintamente como char[] y char *   </span><span class=&#34;kwd&#34;>if</span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;> fgets </span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;>buff</span><span class=&#34;pun&#34;>,</span><span class=&#34;pln&#34;> </span><span class=&#34;lit&#34;>1024</span><span class=&#34;pun&#34;>,</span><span class=&#34;pln&#34;> fd</span><span class=&#34;pun&#34;>) != </span><span class=&#34;pln&#34;>NULL </span><span class=&#34;pun&#34;>)</span><span class=&#34;pln&#34;></span><span class=&#34;pln&#34;></span><span class=&#34;pln&#34;>      fputs</span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;>buff, stdout</span><span class=&#34;pun&#34;>);  // imprime buffer en stdout</span><span class=&#34;pln&#34;></span><span class=&#34;pln&#34;>   fclose</span><span class=&#34;pun&#34;>(</span><span class=&#34;pln&#34;>fp</span><span class=&#34;pun&#34;>);      // OJO: cerrar siempre el descriptor para evitar efectos paranormales</span><span class=&#34;pln&#34;></span></pre><p><span style=&#34;color: inherit; font-family: inherit; font-size: 18px; font-weight: bold;&#34;>Fin de archivo feof()</span></p><p><em><span style=&#34;font-size: 12pt;&#34;>int feof(FILE *F);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Cuando se abre un archivo para entrada binaria, la propia marca EOF se puede leer como un dato cualquiera. Esto podría hacer que la rutina de lectura indicase fin de archivo aún cuando el final físico no se </span><span style=&#34;font-size: 12pt;&#34;>haya alcanzado. Para resolver este problema, C incluye la función feof(), que determina cuando se ha alcanzado el real del archivo leyendo datos binarios</span></p><p><span style=&#34;font-size: 12pt;&#34;>Su prototipo se encuentra en <em><strong>stdio.h</strong></em>. Devuelve cierto si se ha alcanzado el final del archivo, en cualquier </span><span style=&#34;font-size: 12pt;&#34;>otro caso, 0. Por supuesto (moraleja), se puede aplicar también a archivos de texto</span></p><h3>Recorrer archivo con&amp;nbsp;1&amp;nbsp;y&amp;nbsp;1</h3><p><span style=&#34;font-size: 12pt;&#34;>Estas dos funciones son interesantes para cosas como, por ejemplo, leer un fichero al revés (hay, sin embargo, formas mejores de hacer lo mismo)</span></p><h4><em><span style=&#34;font-size: 12pt;&#34;>int fseek(</span></em><em><span style=&#34;font-size: 12pt;&#34;>FILE *F, long int desplz</span></em><em><span style=&#34;font-size: 12pt;&#34;>, int posact);</span></em>&amp;nbsp;</h4><p><span style=&#34;font-size: 12pt;&#34;>Se desplaza el nº de bytes que indica desplaz desde la posición que indica posact. Esta puede vales <em><strong>SEEK_SET</strong></em> (inicio absoluto del fichero), <strong><em>SEEK_CUR</em></strong> (posición actual) o <strong><em>SEEK_END</em></strong></span></p><p><span style=&#34;font-size: 12pt;&#34;>Si no hubo error devuelve 0</span></p><h4><em style=&#34;color: inherit; font-family: inherit;&#34;><span style=&#34;font-size: 12pt;&#34;>long int ftell(</span></em><em style=&#34;color: inherit; font-family: inherit;&#34;><span style=&#34;font-size: 12pt;&#34;>FILE *F</span></em><em style=&#34;color: inherit; font-family: inherit;&#34;><span style=&#34;font-size: 12pt;&#34;>);</span></em></h4><p><span style=&#34;font-size: 12pt;&#34;>No tiene misterio alguno. Devuelve el valor actual&amp;nbsp;del indicador de posición o -1 si error</span></p><h3>Función ferror()</h3><p><em><span style=&#34;font-size: 12pt;&#34;>int ferror(FILE *F);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Su prototipo se encuentra en <em><strong>stdio.h</strong></em>. Determina si se ha producido error en una operación sobre un archivo.&amp;nbsp;</span><span style=&#34;font-size: 12pt;&#34;>F es un puntero a un archivo válido. Devuelve cierto (1) si se ha producido un error en la última&amp;nbsp;</span><span style=&#34;font-size: 12pt;&#34;>operación sobre el archivo. En caso contrario, devuelve falso (0). Debido a que cada operación sobre el archivo actualiza la condicioón de error, se debe llamar a ferror() inmediatamente después de la operación</span></p><h3>Función remove()</h3><p><em><span style=&#34;font-size: 12pt;&#34;>int remove(char *nombre_archivo);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Borra el archivo especificado. Devuelve cero si tiene éxito</span></p><h3>Función fflush()</h3><p><em><span style=&#34;font-size: 12pt;&#34;>int fflush(FILE *F);</span></em></p><p><span style=&#34;font-size: 12pt;&#34;>Escribe todos los datos en el buffer sobre el archivo en el disco</span></p><p><span style=&#34;font-size: 12pt;&#34;>Si se llama esta función con un puntero nulo se vacían todos los buffers de todos los archivos abiertos. Devuelve cero si tiene éxito, en otro caso, devuelve EOF</span>&amp;nbsp;</p><h2>Ejemplo</h2><pre><span class=&#34;cp&#34;>#include</span> <span class=&#34;cpf&#34;>&amp;lt;stdio.h&amp;gt;</span><span class=&#34;cp&#34;>#include</span> <span class=&#34;cpf&#34;>&amp;lt;stdlib.h&amp;gt;</span> <span class=&#34;kt&#34;>int</span> <span class=&#34;nf&#34;>main</span><span class=&#34;p&#34;>()</span><span class=&#34;p&#34;>{</span> 	<span class=&#34;kt&#34;>FILE</span> <span class=&#34;o&#34;>*</span><span class=&#34;n&#34;>archivo</span><span class=&#34;p&#34;>;</span> 	 	<span class=&#34;kt&#34;>char</span> <span class=&#34;n&#34;>caracteres</span><span class=&#34;p&#34;>[</span><span class=&#34;mi&#34;>100</span><span class=&#34;p&#34;>];               /* un buffer de tamaño 100 */</span> 	 	<span class=&#34;n&#34;>archivo</span> <span class=&#34;o&#34;>=</span> <span class=&#34;n&#34;>fopen</span><span class=&#34;p&#34;>(</span><span class=&#34;s&#34;>&#34;pepito.txt&#34;</span><span class=&#34;p&#34;>, </span><span class=&#34;s&#34;>&#34;r&#34;</span><span class=&#34;p&#34;>); /* abrir el archivo */</span> 	 	<span class=&#34;k&#34;>if</span> <span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>archivo</span> <span class=&#34;o&#34;>==</span> <span class=&#34;nb&#34;>NULL</span><span class=&#34;p&#34;>)</span> 		<span class=&#34;n&#34;>exit</span><span class=&#34;p&#34;>(</span><span class=&#34;mi&#34;>1</span><span class=&#34;p&#34;>);                    /* no fue abierto, salir corriendo */</span> 	<span class=&#34;k&#34;>else</span>        <span class=&#34;p&#34;>{</span> 	    <span class=&#34;n&#34;>printf</span><span class=&#34;p&#34;>(</span><span class=&#34;s&#34;>&#34;</span><span class=&#34;se&#34;>
</span><span class=&#34;s&#34;>El contenido del archivo es </span><span class=&#34;se&#34;>

</span><span class=&#34;s&#34;>&#34;</span><span class=&#34;p&#34;>);</span> 	    <span class=&#34;k&#34;>while</span> <span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>feof</span><span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>archivo</span><span class=&#34;p&#34;>)</span> <span class=&#34;o&#34;>==</span> <span class=&#34;mi&#34;>0</span><span class=&#34;p&#34;>)      /* mientras no alcance el final <strong>real</strong> */</span> 	    <span class=&#34;p&#34;>{</span> 		printf(&#34;Ahora LEE
&#34;);<br /><span class=&#34;n&#34;>                fgets</span><span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>caracteres</span><span class=&#34;p&#34;>, </span><span class=&#34;mi&#34;>100</span><span class=&#34;p&#34;>, </span><span class=&#34;n&#34;>archivo</span><span class=&#34;p&#34;>); /* ojo, lee de 100 en 100 */<br /></span>                printf(&#34;Ahora ESCRIBE
&#34;);  		<span class=&#34;n&#34;>printf</span><span class=&#34;p&#34;>(</span><span class=&#34;s&#34;>&#34;%s&#34;</span><span class=&#34;p&#34;>,</span><span class=&#34;n&#34;>caracteres</span><span class=&#34;p&#34;>);</span> 	    <span class=&#34;p&#34;>}</span>        <span class=&#34;p&#34;>}</span>        <span class=&#34;n&#34;>fclose</span><span class=&#34;p&#34;>(</span><span class=&#34;n&#34;>archivo</span><span class=&#34;p&#34;>);                    /* salir cerrando el archivo */</span>	<span class=&#34;k&#34;>return</span> <span class=&#34;mi&#34;>0</span><span class=&#34;p&#34;>;</span><span class=&#34;p&#34;>}</span></pre><h1>Ejercicio</h1><p><span style=&#34;font-size: 12pt;&#34;>El ejercicio Struct Libro del tema 1 incluye manejo de ficheros. Descargar 1</span></p><h2>Información adicional</h2><ol><li><a href=&#34;https://www.tutorialspoint.com/cprogramming/c_file_io.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;><span style=&#34;font-size: 12pt;&#34;>C File I/O</span></a></li><li><a href=&#34;https://www.tutorialspoint.com/c_standard_library/stdio_h.htm&#34; target=&#34;_blank&#34; rel=&#34;noopener noreferrer&#34;><span style=&#34;font-size: 12pt;&#34;>C Library &amp;lt;stdio.h&amp;gt;</span></a></li></ol>"><meta property="og:type" content="article"><meta property="og:url" content="http://localhost:1313/docs/pps/Ficheros/"><meta property="article:section" content="docs"><meta property="article:published_time" content="2017-10-03T00:00:00+00:00"><meta property="article:modified_time" content="2017-10-03T00:00:00+00:00"><title>Manejo de Ficheros en C | PPS GitHub</title><link rel=manifest href=/manifest.json><link rel=icon href=/favicon.png type=image/x-icon><link rel=stylesheet href=/book.min.e246e6a45b940b6ff71d8216783f10a80d910290a7c364c8bfd5d305d8545d62.css integrity="sha256-4kbmpFuUC2/3HYIWeD8QqA2RApCnw2TIv9XTBdhUXWI="><script defer src=/en.search.min.58b7e3f478b50956f06e6c727c6467e2d4d244dfbbc8800a93eb792afba5d788.js integrity="sha256-WLfj9Hi1CVbwbmxyfGRn4tTSRN+7yIAKk+t5Kvul14g="></script><script defer src=/sw.min.6f6f90fcb8eb1c49ec389838e6b801d0de19430b8e516902f8d75c3c8bd98739.js integrity="sha256-b2+Q/LjrHEnsOJg45rgB0N4ZQwuOUWkC+NdcPIvZhzk="></script></head><body dir=ltr><input type=checkbox class="hidden toggle" id=menu-control>
<input type=checkbox class="hidden toggle" id=toc-control><main class="container flex"><aside class=book-menu><div class=book-menu-content><nav><h2 class=book-brand><a href=/><span>PPS GitHub</span></a></h2><div class=book-search><input type=text id=book-search-input placeholder=Search aria-label=Search maxlength=64 data-hotkeys=s/><div class="book-search-spinner hidden"></div><ul id=book-search-results></ul></div><ul><li><a href=/>Intro</a><ul><li><a href=/docs/pps/intro/Linux/>Linux</a></li><li><a href=/docs/pps/intro/Tutorials/>Tutorials</a></li><li><a href=/docs/pps/intro/ManUse/>Uso del Manual</a></li><li><a href=/docs/pps/intro/EditRemoto/>Edit Remoto</a></li><li><a href=/docs/pps/intro/Primer/>Primeros Pasos</a></li></ul></li></ul><ul><li><a href=/docs/pps/StringC/>Strings en C</a></li><li><a href=/docs/pps/EjBase/>Ejercicio Base</a></li><li><a href=/docs/pps/Structs/>Structs en C</a></li><li><a href=/docs/pps/Ficheros/ class=active>Ficheros en C</a></li></ul><ul><li><a href=/posts/>Noticias</a></li><li><a href=https://github.com/alex-shpak/hugo-book target=_blank rel=noopener>Github</a></li><li><a href=https://themes.gohugo.io/hugo-book/ target=_blank rel=noopener>Hugo Themes</a></li></ul></nav><script>(function(){var a=document.querySelector("aside.book-menu nav");addEventListener("beforeunload",function(b){localStorage.setItem("menu.scrollTop",a.scrollTop)}),a.scrollTop=localStorage.getItem("menu.scrollTop")})()</script></div></aside><div class=book-page><header class=book-header><div class="flex align-center justify-between"><label for=menu-control><img src=/svg/menu.svg class=book-icon alt=Menu></label>
<strong>Manejo de Ficheros en C</strong>
<label for=toc-control><img src=/svg/toc.svg class=book-icon alt="Table of Contents"></label></div><aside class="hidden clearfix"><nav id=TableOfContents></nav></aside></header><article class=markdown><h2>El puntero a un archivo:&nbsp;FILE *fptr;</h2><ul><li><span style=font-size:12pt><em><strong>fptr</strong></em> es un puntero a una estructura que define información sobre un archivo, incluyendo el nombre, el estado y la posición actual en el archivo. Es mantenido por el sistema y resulta clave para el funcionamiento de las funciones de E/S con buffer</span></li><li><span style=font-size:12pt>El tipo <em><strong>FILE</strong></em>&nbsp;(descriptor de fichero) se define en <em><strong>stdio.h</strong></em></span></li><li><span style=font-size:12pt>Los archivos se dicen de texto o binarios según la naturaleza de su contenido</span></li></ul><h5>Declaración <a href=https://tldp.org/LDP/tlk/ds/ds.html>struct file</a>:</h5><pre>struct file {
  mode_t f_mode;
  loff_t f_pos;
  unsigned short f_flags;
  unsigned short f_count;
  unsigned long f_reada, f_ramax, f_raend, f_ralen, f_rawin;
  struct file *f_next, *f_prev;
  int f_owner;         /* pid or -pgrp where SIGIO should be sent */
  struct inode * f_inode;
  struct file_operations * f_op;
  unsigned long f_version;
  void *private_data;  /* needed for tty driver, and maybe others */
};</pre><h2>Resumen de funciones</h2><ul><li><span style=font-size:12pt>fopen(): Abre un archivo</span></li><li><span style=font-size:12pt>fclose(): Cierra un archivo</span></li><li><span style=font-size:12pt>fgets(): Lee un string</span></li><li><span style=font-size:12pt>fputs(): Escribe string</span></li><li><span style=font-size:12pt>ftell(), fseek(): Recorrer archivo</span></li><li><span style=font-size:12pt>fprintf(): Escribe una salida con formato en el archivo</span></li><li><span style=font-size:12pt>fscanf(): Lee una entrada con formato desde el archivo</span></li><li><span style=font-size:12pt>feof(): Cierto si fin del archivo</span></li><li><span style=font-size:12pt>ferror(): Cierto si se produce un error</span></li><li><span style=font-size:12pt>rewind(): Se posiciona al principio del mismo</span></li><li><span style=font-size:12pt>remove(): Borra archivo</span></li><li><span style=font-size:12pt>fflush(): Vacia archivo</span></li></ul><p>&nbsp;</p><h2>Operaciones básicas</h2><h3>Apertura de un archivo</h3><p><span style=font-size:12pt><a href=https://www.tutorialspoint.com/c_standard_library/c_function_fopen.htm target=_blank rel="noopener noreferrer">fopen()</a> abre un bu<span style=font-size:12pt>ffer y lo asocia a un archivo</span></span></p><p><em><span style=font-size:12pt>FILE * fopen(const char * nombre_archivo, const char * modo);</span></em></p><p><span style=font-size:12pt>nombre_archivo es un puntero a una cadena de caracteres que representan un nombre valido del&nbsp;</span><span style=font-size:12pt>archivo y puede incluir una especificación del directorio (path)&nbsp;</span><span style=font-size:12pt>la cadena a la que apunta modo determina como se abre el archivo. Los valores permitidos para modo son:</span></p><ul><li><span style=font-size:12pt>&nbsp;r: Abre un archivo de texto para lectura</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>w: Crea un archivo de texto para escritura</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>a: Abre un archivo de texto para añadir</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>rb: Abre un archivo en modo lectura binaria</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>wb: Crea un archivo en modo escritura binaria</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>ab: Abre un archivo binario para añadir</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>r+: Abre un archivo de texto para lectura&nbsp;/ escritura</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>w+: Crea un archivo de texto para escritura&nbsp;/ escritura</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>a+: Añade o crea un archivo de texto para lectura / escritura</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>r+b: Abre un archivo binario para lectura / escritura</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>w+b: Crea un archivo binario para lectura / escritura</span></li><li><span style=font-size:12pt></span><span style=font-size:12pt>a+b: Añade o crea un archivo binario para lectura / escritura</span></li></ul><p><span style=font-size:12pt>Siempre conviene tener presente lo siguiente:</span></p><ul><li><span style=font-size:12pt>fopen() devuelve un puntero a archivo. Un programa nunca debe alterar el valor de ese puntero. Si se produce un error cuando se esta intentando abrir un archivo, fopen() devuelve un puntero nulo</span></li><li><span style=font-size:12pt>El modo texto o binario tiene múltiples implicaciones. Por ejemplo, la relativa a la interpretación de los caracteres especiales como son el salto de línea (retorno de carro) o el fin de línea</span></li></ul><h3>Cierre de un archivo</h3><p><span style=font-size:12pt>fclose() cierra una secuencia o buffer previamente abierta mediante una llamada a fopen(). Escribe toda la </span><span style=font-size:12pt>información aún en el buffer al disco y realiza un cierre formal del archivo a nivel del sistema </span><span style=font-size:12pt>operativo. Un error en el cierre (el no cierre, por ejemplo) de una secuencia puede generar todo tipo de problemas, incluyendo la pérdida de los datos, la destrucción de archivos y probables errores esotéricos en el programa. El prototipo de esta función es:</span></p><p><em><span style=font-size:12pt>int fclose(FILE *F);</span></em></p><p><span style=font-size:12pt>Si devuelve un valor cero significa éxito (curioso, pero cierto ?)</span></p><h3>Leer y/o escribir en un archivo con fprintf() y fscanf()</h3><p><em><span style=font-size:12pt>int fprintf(FILE *F, const char *cadena_de_control, .....);</span></em><br><em><span style=font-size:12pt>int fscanf(FILE *F, const char *cadena_de_control, .....);</span></em></p><p><span style=font-size:12pt>Como <a href=https://www.tutorialspoint.com/c_standard_library/c_function_printf.htm target=_blank rel="noopener noreferrer"><em><strong>prinft()</strong></em></a> y <a href=https://www.tutorialspoint.com/c_standard_library/c_function_scanf.htm target=_blank rel="noopener noreferrer"><em><strong>scanf()</strong></em></a> excepto que operan sobre archivo</span></p><h3>Leer y/o escribir en un archivo con <a href=https://www.tutorialspoint.com/c_standard_library/c_function_fgets.htm target=_blank rel="noopener noreferrer">fgets()</a> y <a href=https://www.tutorialspoint.com/c_standard_library/c_function_fputs.htm target=_blank rel="noopener noreferrer">fputs()</a></h3><p><span style=font-size:12pt>Funciones especialmente adecuadas para leer y escribir archivos de texto</span></p><h4><em><span style=font-size:12pt>char *fgets(char *str, int long, FILE *F);</span></em>&nbsp;</h4><p><span style=font-size:12pt>Si se alcanza el EOF (End of File) la llamada fgets() retorna NULL</span></p><h4><em><span style=font-size:12pt>char *fputs(char *str, FILE *F);</span></em></h4><pre class="prettyprint notranslate prettyprinted"><span class=pln>   char buff[1024]; // Buffer en memoria de 1024 caracteres<br>   FILE </span><span class=pun>*</span><span class=pln>fd</span><span class=pun>;        // Descriptor de fichero</span><span class=pln>   </span><span class=pln>
<p></span><span class=pln>   fd </span><span class=pun>=</span><span class=pln> fopen</span><span class=pun>(</span><span class=str>&quot;/tmp/ejemplo.txt&quot;</span><span class=pln> </span><span class=pun>,</span><span class=pln> </span><span class=str>&ldquo;r&rdquo;</span><span class=pun>); // Abrir en modo solo lectura</span><span class=pln>
</span><span class=kwd>if</span><span class=pun>(</span><span class=pln>fd </span><span class=pun>==</span><span class=pln> NULL</span><span class=pun>)</span><span class=pln> </span><span class=pun>{</span><span class=pln>
perror</span><span class=pun>(</span><span class=str>&ldquo;Error al abrir /tmp/ejemplo.txt&rdquo;</span><span class=pun>); // Mostrar error en stderr</span><span class=pln>
</span><span class=kwd>return</span><span class=pun>(-</span><span class=lit>1</span><span class=pun>);   // Devolver error genérico</span><span class=pln>
</span><span class=pun>}<br></span><span class=pln>   // Leer máximo 1024 caracteres; podrían ser menos<br>   // buff funciona indistintamente como char[] y char *
</span><span class=kwd>if</span><span class=pun>(</span><span class=pln> fgets </span><span class=pun>(</span><span class=pln>buff</span><span class=pun>,</span><span class=pln> </span><span class=lit>1024</span><span class=pun>,</span><span class=pln> fd</span><span class=pun>) != </span><span class=pln>NULL </span><span class=pun>)</span><span class=pln></span><span class=pln>
</span><span class=pln>      fputs</span><span class=pun>(</span><span class=pln>buff, stdout</span><span class=pun>);  // imprime buffer en stdout</span><span class=pln>
</span><span class=pln>   fclose</span><span class=pun>(</span><span class=pln>fp</span><span class=pun>);      // OJO: cerrar siempre el descriptor para evitar efectos paranormales</span><span class=pln>
</span></pre></p><p><span style=color:inherit;font-family:inherit;font-size:18px;font-weight:700>Fin de archivo feof()</span></p><p><em><span style=font-size:12pt>int feof(FILE *F);</span></em></p><p><span style=font-size:12pt>Cuando se abre un archivo para entrada binaria, la propia marca EOF se puede leer como un dato cualquiera. Esto podría hacer que la rutina de lectura indicase fin de archivo aún cuando el final físico no se </span><span style=font-size:12pt>haya alcanzado. Para resolver este problema, C incluye la función feof(), que determina cuando se ha alcanzado el real del archivo leyendo datos binarios</span></p><p><span style=font-size:12pt>Su prototipo se encuentra en <em><strong>stdio.h</strong></em>. Devuelve cierto si se ha alcanzado el final del archivo, en cualquier </span><span style=font-size:12pt>otro caso, 0. Por supuesto (moraleja), se puede aplicar también a archivos de texto</span></p><h3>Recorrer archivo con&nbsp;<a href=https://www.tutorialspoint.com/c_standard_library/c_function_fseek.htm target=_blank rel="noopener noreferrer">fseek()</a>&nbsp;y&nbsp;<a href=https://www.tutorialspoint.com/c_standard_library/c_function_ftell.htm target=_blank rel="noopener noreferrer">ftell()</a></h3><p><span style=font-size:12pt>Estas dos funciones son interesantes para cosas como, por ejemplo, leer un fichero al revés (hay, sin embargo, formas mejores de hacer lo mismo)</span></p><h4><em><span style=font-size:12pt>int fseek(</span></em><em><span style=font-size:12pt>FILE *F, long int desplz</span></em><em><span style=font-size:12pt>, int posact);</span></em>&nbsp;</h4><p><span style=font-size:12pt>Se desplaza el nº de bytes que indica desplaz desde la posición que indica posact. Esta puede vales <em><strong>SEEK_SET</strong></em> (inicio absoluto del fichero), <strong><em>SEEK_CUR</em></strong> (posición actual) o <strong><em>SEEK_END</em></strong></span></p><p><span style=font-size:12pt>Si no hubo error devuelve 0</span></p><h4><em style=color:inherit;font-family:inherit><span style=font-size:12pt>long int ftell(</span></em><em style=color:inherit;font-family:inherit><span style=font-size:12pt>FILE *F</span></em><em style=color:inherit;font-family:inherit><span style=font-size:12pt>);</span></em></h4><p><span style=font-size:12pt>No tiene misterio alguno. Devuelve el valor actual&nbsp;del indicador de posición o -1 si error</span></p><h3>Función ferror()</h3><p><em><span style=font-size:12pt>int ferror(FILE *F);</span></em></p><p><span style=font-size:12pt>Su prototipo se encuentra en <em><strong>stdio.h</strong></em>. Determina si se ha producido error en una operación sobre un archivo.&nbsp;</span><span style=font-size:12pt>F es un puntero a un archivo válido. Devuelve cierto (1) si se ha producido un error en la última&nbsp;</span><span style=font-size:12pt>operación sobre el archivo. En caso contrario, devuelve falso (0). Debido a que cada operación sobre el archivo actualiza la condicioón de error, se debe llamar a ferror() inmediatamente después de la operación</span></p><h3>Función remove()</h3><p><em><span style=font-size:12pt>int remove(char *nombre_archivo);</span></em></p><p><span style=font-size:12pt>Borra el archivo especificado. Devuelve cero si tiene éxito</span></p><h3>Función fflush()</h3><p><em><span style=font-size:12pt>int fflush(FILE *F);</span></em></p><p><span style=font-size:12pt>Escribe todos los datos en el buffer sobre el archivo en el disco</span></p><p><span style=font-size:12pt>Si se llama esta función con un puntero nulo se vacían todos los buffers de todos los archivos abiertos. Devuelve cero si tiene éxito, en otro caso, devuelve EOF</span>&nbsp;</p><h2>Ejemplo</h2><pre><span class=cp>#include</span> <span class=cpf>&lt;stdio.h&gt;</span>
<span class=cp>#include</span> <span class=cpf>&lt;stdlib.h&gt;</span>
<p><span class=kt>int</span> <span class=nf>main</span><span class=p>()</span>
<span class=p>{</span>
<span class=kt>FILE</span> <span class=o>*</span><span class=n>archivo</span><span class=p>;</span></p>
<pre><code>&lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;caracteres&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;];               /* un buffer de tamaño 100 */&lt;/span&gt;
 
&lt;span class=&quot;n&quot;&gt;archivo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;fopen&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;pepito.txt&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;r&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;); /* abrir el archivo */&lt;/span&gt;
 
&lt;span class=&quot;k&quot;&gt;if&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;archivo&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;NULL&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
	&lt;span class=&quot;n&quot;&gt;exit&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);                    /* no fue abierto, salir corriendo */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;else&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;El contenido del archivo es &lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\n\n&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;k&quot;&gt;while&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;feof&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;archivo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;==&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)      /* mientras no alcance el final &lt;strong&gt;real&lt;/strong&gt; */&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
	printf(&quot;Ahora LEE\n&quot;);&lt;br /&gt;&lt;span class=&quot;n&quot;&gt;                fgets&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caracteres&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;100&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;, &lt;/span&gt;&lt;span class=&quot;n&quot;&gt;archivo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;); /* ojo, lee de 100 en 100 */&lt;br /&gt;&lt;/span&gt;                printf(&quot;Ahora ESCRIBE\n&quot;); 
	&lt;span class=&quot;n&quot;&gt;printf&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&quot;%s&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;caracteres&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;n&quot;&gt;fclose&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;archivo&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);                    /* salir cerrando el archivo */&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
</code></pre><p><span class=p>}</span></pre></p><h1>Ejercicio</h1><p><span style=font-size:12pt>El ejercicio Struct Libro del tema <a href="index.php?option=com_content&view=article&id=16:structs&catid=11:pps">Structs y Union</a> incluye manejo de ficheros. Descargar <a href=https://mega.nz/#!3UUyGYgA!ugZg-xMTvSBzIkAGAX6WS7kPGfEBDCYe8kja1khgT7w target=_blank rel=noopener>aquí</a></span></p><h2>Información adicional</h2><ol><li><a href=https://www.tutorialspoint.com/cprogramming/c_file_io.htm target=_blank rel="noopener noreferrer"><span style=font-size:12pt>C File I/O</span></a></li><li><a href=https://www.tutorialspoint.com/c_standard_library/stdio_h.htm target=_blank rel="noopener noreferrer"><span style=font-size:12pt>C Library &lt;stdio.h></span></a></li></ol></article><footer class=book-footer><div class="flex flex-wrap justify-between"></div><script>(function(){function a(c){const a=window.getSelection(),b=document.createRange();b.selectNodeContents(c),a.removeAllRanges(),a.addRange(b)}document.querySelectorAll("pre code").forEach(b=>{b.addEventListener("click",function(c){a(b.parentElement),navigator.clipboard&&navigator.clipboard.writeText(b.parentElement.textContent)})})})()</script></footer><div class=book-comments></div><label for=menu-control class="hidden book-menu-overlay"></label></div><aside class=book-toc><div class=book-toc-content><nav id=TableOfContents></nav></div></aside></main></body></html>